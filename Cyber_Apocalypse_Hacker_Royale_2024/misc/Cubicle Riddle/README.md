# Cubicle Riddle

## Challenge
Navigate the haunting riddles that echo through the forest, for the Cubicle Riddle is no ordinary obstacle. The answers you seek lie within the whispers of the ancient trees and the unseen forces that govern this mystical forest. Will your faction decipher the enigma and claim the knowledge concealed within this challenge, or will the forest consume those who dare to unravel its secrets? The fate of your faction rests in you.

### Attachment
- [misc_cubicle_riddle.zip](./handout/misc_cubicle_riddle.zip)

## Solution
In this web challenge, we're basically given a Python3 riddle:
```python
import types
from random import randint

class Riddler:
	max_int: int
	min_int: int
	co_code_start: bytes
	co_code_end: bytes
	num_list: list[int]

	def __init__(self) -> None:
		self.max_int = 1000
		self.min_int = -1000
		self.co_code_start = b"d\x01}\x01d\x02}\x02"
		self.co_code_end = b"|\x01|\x02f\x02S\x00"
		self.num_list = [randint(self.min_int, self.max_int) for _ in range(10)]
	
	def ask_riddle(self) -> str:
		return """ 'In arrays deep, where numbers sprawl,
		I lurk unseen, both short and tall.
		Seek me out, in ranks I stand,
		The lowest low, the highest grand.
		
		What am i?'
		"""
	
	def check_answer(self, answer: bytes) -> bool:
		_answer_func: types.FunctionType = types.FunctionType(
			self._construct_answer(answer), {}
		)
		return _answer_func(self.num_list) == (min(self.num_list), max(self.num_list))
	
	def _construct_answer(self, answer: bytes) -> types.CodeType:
		co_code: bytearray = bytearray(self.co_code_start)
		co_code.extend(answer)
		co_code.extend(self.co_code_end)

		code_obj: types.CodeType = types.CodeType(
			1,                                 
			0,                                 
			0,                                 
			4,                                 
			3,                                 
			3,                                 
			bytes(co_code),                    
			(None, self.max_int, self.min_int),
			(),                                
			("num_list", "min", "max", "num"), 
			__file__,                          
			"_answer_func",                    
			"_answer_func",                    
			1,                                 
			b"",                               
			b"",                               
			(),                                
			(),                                
		)
		return code_obj
```

The solution to the riddle itself would be a tuple containing the smallest and the biggest number of a given list, e.g. `(min, max)`, which can easily be computed using the following function:
```python
def _answer_func(num_list):
	min = 1000
	max = -1000
	for num in num_list:
		if min > num:
			min = num
		if max < num:
			max = num
	return (min, max)
```
But we are required to supply the answer as a string of Python byte-code. Luckily, Python let's us export the byte-code of a given function using some built-in properties:
```python
solution = _answer_func.__code__.co_code
```

Now we only need a bit of stub to interact with the challenge:
```python
from pwn import *

server = '83.136.248.36' #'192.168.178.79'
port = 52708 #1337

delimiter = b'\n___________________________________________________________\n'

solution = ','.join([str(x) for x in solution]) # Reformat the byte-code in the expected format.

def answerInt(val):
	global conn
	val = str(val)
	answerString(val)

def answerString(val):
	print(val)
	conn.sendline(val.encode())

conn = remote(server, port)
print(conn.readuntil(b'(Choose wisely) > ').decode())
answerInt(1)
print(conn.readuntil(b'(Answer wisely) > ').decode())
answerString(solution)
print(conn.readuntil(delimiter).decode())
print(conn.readuntil(delimiter).decode())
conn.close()
```
And thus we receive our flag: `HTB{r1ddle_m3_th1s_r1ddle_m3_th4t}`

### Troubleshooting
At first I've been trying to run this script on a Windows 10 machine using Python version 3.10.4, but this did yield a different byte-code than the server was expecting. I didn't follow through on debugging this to the end, so I don't actually know, if the operating system or the python version were at fault here.

Running the same script on a Kali linux machine with Python version 3.11.6, the generated byte-code did run on the server without any errors.

That's why my [solver.py](./solver.py) file actually contains the byte-code as a string.

## Resources
 - [Disassembler for Python bytecode](https://docs.python.org/3/library/dis.html)
 - [Github, Python opcodes](https://github.com/python/cpython/blob/main/Include/opcode_ids.h)
 - [Github, Python handling different opcodes](https://github.com/python/cpython/blob/d48ecebad5ac78a1783e09b0d32c211d9754edf4/Python/ceval.c#L1266)